import * as ai0 from "ai";
import { AsyncIterableStream, InferUIMessageChunk, Tool, ToolSet, UIDataTypes, UIMessage, UIMessagePart, UITools } from "ai";

//#region src/api/chat.d.ts
interface Chat {
  readonly id: string;
}
interface MessageOptions {
  /**
   * behavior of the chat when sending this message.
   *
   * - "enqueue" will add messages to the chat and start the chat eventually.
   * - "interrupt" will interrupt the chat if running and send messages.
   * - "append" will add messages to the chat.
   */
  readonly behavior?: "enqueue" | "interrupt" | "append";
}
interface Message<METADATA = unknown, DATA_TYPES extends UIDataTypes = UIDataTypes, TOOLS extends UITools = UITools> {
  readonly role: UIMessage["role"];
  readonly parts: UIMessagePart<DATA_TYPES, TOOLS>[];
  readonly metadata?: METADATA;
}
declare const chat: Readonly<{
  upsert: (id: string) => Promise<Chat>;
  message: (id: string, message: Message, options?: MessageOptions) => Promise<void>;
}>;
//#endregion
//#region src/api/tools.d.ts
/**
 * ToolWith is a tool that supports the "with" method.
 *
 * @param CONTEXT The context type.
 * @param TOOL The tool type.
 * @returns The tool with the given context.
 */
type ToolWith<CONTEXT, TOOL extends Tool> = TOOL & {
  with: (context: CONTEXT) => TOOL;
};
/**
 * Tools are helpers for managing tools.
 */
declare const tools: {
  /**
   * with adds context to a set of tools that supports the "with" method.
   *
   * @param context
   * @param tools
   * @returns
   */
  with<TOOLS extends Record<string, ToolWith<CONTEXT, Tool>>, CONTEXT>(tools: TOOLS, context: CONTEXT): Record<string, Tool>;
  /**
   * prefix adds a prefix to all the tools in a tool set.
   *
   * @param tools The tool set to prefix.
   * @param prefix The prefix to add to the tools.
   * @returns The prefixed tool set.
   */
  prefix(tools: ToolSet, prefix: string): ToolSet;
};
//#endregion
//#region src/api/storage.d.ts
/**
 * Storage is namespaced by the agent.
 */
declare const storage: Readonly<{
  get: (key: string) => Promise<string | undefined>;
  set: (key: string, value: string) => Promise<void>;
}>;
//#endregion
//#region src/api/index.d.ts
/**
 * SendMessagesResponse is the response of the sendMessages function.
 * It can be a stream of messages or an arbitrary response.
 */
type SendMessagesResponse = {
  toUIMessageStream(): AsyncIterableStream<InferUIMessageChunk<UIMessage>>;
} | Response | ReadableStream<InferUIMessageChunk<UIMessage>>;
/**
 * SendMessagesOptions is the options for the sendMessages function.
 */
interface SendMessagesOptions<MESSAGE extends UIMessage = UIMessage> {
  readonly messages: MESSAGE[];
  readonly abortSignal?: AbortSignal;
  readonly request: Request;
}
interface Agent<MESSAGE extends UIMessage = UIMessage> {
  sendMessages(options: SendMessagesOptions<MESSAGE>): Promise<SendMessagesResponse> | SendMessagesResponse;
  webhook?(request: Request): Promise<Response | void>;
}
/**
 * AgentDefaultExport is the expected default export of a compiled agent.
 * All routing logic is handled by the agent function.
 *
 * This maximizes flexibility over the agent's behavior -
 * allowing users to add arbitrary routing logic to the agent.
 */
type AgentDefaultExport = {
  readonly version: "v0";
  fetch: (request: Request) => Promise<Response> | Response;
  readonly supportsWebhooks?: boolean;
};
/**
 * agent is the main function to create a Blink agent.
 *
 * @param agent
 * @returns
 */
declare function agent<MESSAGE extends UIMessage = UIMessage>(agent: Agent<MESSAGE>): AgentDefaultExport;
type StreamResponseFormat = "ui-message" | "openai-chat" | "openai-response" | "anthropic" | "google" | "xai";
declare function withResponseFormat(response: Response, format: StreamResponseFormat): Response;
declare const _default: {
  agent: typeof agent;
  chat: Readonly<{
    upsert: (id: string) => Promise<Chat>;
    message: (id: string, message: Message, options?: MessageOptions) => Promise<void>;
  }>;
  storage: Readonly<{
    get: (key: string) => Promise<string | undefined>;
    set: (key: string, value: string) => Promise<void>;
  }>;
  tools: {
    with<TOOLS extends Record<string, ToolWith<CONTEXT, ai0.Tool>>, CONTEXT>(tools: TOOLS, context: CONTEXT): Record<string, ai0.Tool>;
    prefix(tools: ai0.ToolSet, prefix: string): ai0.ToolSet;
  };
};
//#endregion
export { Agent, AgentDefaultExport, Chat, Message, MessageOptions, SendMessagesOptions, SendMessagesResponse, StreamResponseFormat, ToolWith, agent, chat, _default as default, storage, tools, withResponseFormat };